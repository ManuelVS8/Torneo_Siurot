<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Torneo de Ajedrez por equipos</title>
<meta name="theme-color" content="#e67e22">
<!-- Favicon -->
<link rel="icon" href="https://raw.githubusercontent.com/ManuelVS8/Ajedrez_Equipos/refs/heads/main/Torneo_ajedrez.ico" type="image/x-icon">
<!-- MANIFESTO PARA PWA -->
<link rel="manifest" href="manifest.json">
<!-- Librer√≠a jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
:root {
--primary: #2c3e50;
--secondary: #ecf0f1;
--accent: #e67e22;
--accent-light: #fcefe9;
--success: #27ae60;
--win-color: #27ae60;
--loss-color: #c0392b;
--draw-color: #3498db;
--round-done: #d1ecf1;
--round-done-text: #0c5460;
--danger: #c0392b;
--text: #333;
--light-text: #7f8c8d;
--border: #bdc3c7;
--card-bg: #ffffff;
}
* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
body { margin: 0; padding: 0; background-color: var(--secondary); color: var(--text); padding-bottom: 80px; }
header {
background-color: var(--primary);
color: white;
padding: 1rem;
text-align: center;
position: sticky;
top: 0;
z-index: 100;
box-shadow: 0 2px 5px rgba(0,0,0,0.2);
display: flex;
justify-content: space-between;
align-items: center;
}
.header-text { text-align: left; flex: 1; }
h1 { margin: 0; font-size: 1.2rem; }
.subtitle { font-size: 0.8rem; opacity: 0.9; margin-top: 2px; font-weight: normal; }
#adminBtn {
background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white;
border-radius: 50%; width: 40px; height: 40px; font-size: 1.2rem; cursor: pointer;
display: flex; align-items: center; justify-content: center; transition: all 0.3s;
margin-left: 10px; flex-shrink: 0;
}
#adminBtn:active { background-color: rgba(255,255,255,0.3); }
#adminBtn.unlocked { background-color: var(--success); border-color: var(--success); }
.container { padding: 1rem; max-width: 700px; margin: 0 auto; }
.tab-content { display: none; animation: fadeIn 0.3s; }
.tab-content.active { display: block; }
@keyframes fadeIn { from { opacity: 0; } to { opacity:1; } }
.card {
background: var(--card-bg);
border-radius: 10px;
padding: 1rem;
margin-bottom: 1rem;
box-shadow: 0 2px 5px rgba(0,0,0,0.05);
position: relative;
}
body.is-locked .editable-element {
opacity: 0.3;
pointer-events: none;
user-select: none;
}
.lock-overlay {
display: none;
text-align: center;
color: var(--danger);
padding: 10px;
font-weight: bold;
font-size: 0.9rem;
background: rgba(255,255,255,0.9);
border-radius: 5px;
margin-bottom: 10px;
}
body.is-locked .show-lock-msg .lock-overlay {
display: block;
}
/* --- PARCHES DE SEGURIDAD PARA EL MODAL --- */
body.is-locked .modal .editable-element,
body.is-locked .modal-content input,
body.is-locked .modal-content button {
opacity: 1 !important;
pointer-events: auto !important;
user-select: auto !important;
}
button {
background-color: var(--primary); color: white; border: none;
padding: 12px 20px; border-radius: 5px; font-size: 1rem; cursor: pointer;
width: 100%; margin-top: 10px; font-weight: bold;
transition: background 0.2s;
}
button:active { transform: scale(0.98); }
button.secondary { background-color: var(--light-text); }
button.export { background-color: var(--success); }
button.danger { background-color: var(--danger); }
button.small { padding: 8px 15px; font-size: 0.9rem; width: auto; margin-top: 0; }
button.toggle-active { background-color: var(--accent); color: white; }
button:disabled { background-color: #ccc; cursor: not-allowed; }
.info-box {
background-color: #e8f4f8;
border-left: 4px solid var(--accent);
padding: 10px;
margin-bottom: 15px;
font-size: 0.85rem;
color: #444;
}
.info-box strong { color: var(--primary); display: block; margin-bottom: 4px; }
/* --- STYLES TEAM SETUP --- */
.team-setup-card {
border: 1px solid var(--border);
border-radius: 8px;
padding: 15px;
margin-bottom: 15px;
background: #fafafa;
}
.team-header {
display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
}
.team-header input {
font-weight: bold; font-size: 1.1rem; width: 70%; padding: 5px;
border: 1px solid var(--border); border-radius: 4px;
}
.player-list {
display: flex; flex-direction: column; gap: 8px;
}
.player-row {
display: flex; gap: 5px; align-items: center;
}
.player-row input {
flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: 4px;
}
.player-num {
color: var(--light-text); font-weight: bold; width: 20px; font-size: 0.9rem;
}
/* --- STYLES MATCHES --- */
.team-match-card {
background: var(--card-bg);
border-radius: 8px;
padding: 15px;
margin-bottom: 20px;
border-left: 5px solid var(--accent);
box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
.team-match-header {
display: flex; justify-content: space-between; align-items: center;
margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;
}
.team-score-display {
font-size: 1.2rem; font-weight: bold; color: var(--primary);
background: #eee; padding: 5px 15px; border-radius: 20px;
}
.team-names {
text-align: center; font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;
}
.team-subtitle {
text-align: center; font-size: 0.8rem; color: var(--light-text); text-transform: uppercase; letter-spacing: 1px;
}
.board-row {
display: flex; flex-direction: column; background: #f9f9f9;
border-radius: 6px; padding: 10px; margin-bottom: 8px; border: 1px solid #eee;
}
.board-players {
display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 0.95rem;
}
.board-p1 { font-weight: 600; color: var(--primary); }
.board-p2 { font-weight: 600; color: var(--text); text-align: right; }
.board-p1.win { color: var(--win-color); font-weight: 800; }
.board-p2.win { color: var(--win-color); font-weight: 800; }
.board-p1.loss { color: var(--loss-color); }
.board-p2.loss { color: var(--loss-color); }
.draw { color: var(--draw-color); }
.board-select {
width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border);
background: white; font-size: 0.9rem;
}
/* --- TABLE STYLES --- */
.toggle-container {
display: flex;
gap: 10px;
margin-bottom: 15px;
}
table { width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; }
th, td { padding: 10px 5px; text-align: left; border-bottom: 1px solid #eee; font-size: 0.9rem; }
th { background-color: var(--primary); color: white; font-size: 0.8rem; }
tr:nth-child(even) { background-color: #f8f9fa; }
.sb-col { text-align: right; font-size: 0.8rem; color: var(--light-text); }
.points-col { text-align: right; font-weight: bold; color: var(--accent); font-size: 1.1rem; }
.rank-col { width: 30px; text-align: center; color: var(--light-text); font-weight: bold; }
/* --- MODALS & UTILS --- */
.modal {
display: none; position: fixed; z-index: 200; left: 0; top: 0; width: 100%; height: 100%;
background-color: rgba(0,0,0,0.5); justify-content: center; align-items: center;
}
.modal-content {
background-color: white; padding: 25px; border-radius: 10px; width: 90%; max-width: 400px; text-align: center;
box-shadow: 0 10px 25px rgba(0,0,0,0.2);
}
.modal-buttons { display: flex; gap: 10px; }
.modal-buttons button { width: 50%; margin-top: 0; }
#loadingOverlay {
display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
background: rgba(255,255,255,0.8); z-index: 300; justify-content: center; align-items: center; flex-direction: column;
}
.spinner {
border: 5px solid #f3f3f3; border-top: 5px solid var(--accent); border-radius: 50%;
width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.bottom-nav {
position: fixed; bottom: 0; width: 100%; background: white; display: flex;
justify-content: space-around; padding: 10px 0; box-shadow: 0 -2px 5px rgba(0,0,0,0.1); z-index: 99;
}
.nav-item { text-align: center; color: var(--light-text); font-size: 0.75rem; cursor: pointer; flex: 1; user-select: none; }
.nav-item.active { color: var(--accent); font-weight: bold; }
.nav-icon { font-size: 1.2rem; display: block; margin-bottom: 2px; }
.round-selector { display: flex; overflow-x: auto; gap: 10px; padding-bottom: 10px; margin-bottom: 15px; }
.round-chip {
background: #eee; color: #555; padding: 5px 15px; border-radius: 20px; white-space: nowrap;
font-size: 0.9rem; cursor: pointer; transition: all 0.2s; border: 1px solid transparent;
}
.round-chip.has-results { background-color: var(--round-done); color: var(--round-done-text); border: 1px solid var(--round-done-text); }
.round-chip.active { background: var(--accent) !important; color: white !important; border-color: var(--accent) !important; }
#toast {
visibility: hidden; min-width: 250px; background-color: #333; color: #fff;
text-align: center; border-radius: 4px; padding: 16px; position: fixed;
z-index: 1000; left: 50%; bottom: 90px; transform: translateX(-50%); font-size: 1rem;
}
#toast.show { visibility: visible; animation: fadein 0.5s, fadeout 0.5s 2.5s; }
@keyframes fadein { from {bottom: 60px; opacity: 0;} to {bottom: 90px; opacity: 1;} }
@keyframes fadeout { from {bottom: 90px; opacity: 1;} to {bottom: 60px; opacity: 0;} }
</style>
</head>
<body class="is-locked">
<div id="loadingOverlay">
<div class="spinner"></div>
<div id="loadingText">Conectando...</div>
</div>
<header>
<div class="header-text">
<h1>IV Torneo interescolar</h1>
<div class="subtitle">La Palma del Condado 2026</div>
</div>
<button id="adminBtn" onclick="openPasswordModal()" title="Admin">üîí</button>
</header>
<div class="container">
<!-- TAB 1: CONFIGURACI√ìN DE EQUIPOS -->
<div id="tab-setup" class="tab-content active">
<div class="card show-lock-msg">
<h3>1. Configuraci√≥n de Equipos</h3>
<p class="small">Crea los equipos y a√±ade sus jugadores.</p>
<div class="lock-overlay">üîí Modo lectura: Pulsa el candado para editar</div>
<div id="teamsSetupContainer">
<!-- Los equipos se inyectar√°n aqu√≠ din√°micamente -->
</div>
<button class="editable-element" style="background-color: var(--accent); margin-top: 15px;" onclick="addNewTeamUI()">+ A√±adir Nuevo Equipo</button>
<hr style="margin: 20px 0; border: 0; border-top: 1px solid #eee;">
<button class="editable-element" onclick="confirmStartTournament()">Crear / Actualizar Torneo</button>
</div>
<div class="card show-lock-msg" id="resetCard" style="display:none;">
<h3>Zona de Peligro</h3>
<p style="color:var(--danger); font-size:0.9rem;">Esto borrar√° todos los resultados y equipos.</p>
<div class="lock-overlay">üîí Zona protegida</div>
<button class="editable-element danger" onclick="confirmResetTournament()">Borrar Todo</button>
</div>
</div>
<!-- TAB 2: RONDAS -->
<div id="tab-rounds" class="tab-content">
<div class="round-selector" id="roundSelector"></div>
<div id="matchesContainer"></div>
<div style="height: 20px;"></div>
<div class="card show-lock-msg" style="padding: 0; background: transparent; box-shadow: none;">
<div class="lock-overlay">üîí Necesitas desbloquear para guardar</div>
<button id="saveBtn" class="editable-element" onclick="syncToGoogle()">Guardar resultados</button>
</div>
</div>
<!-- TAB 3: CLASIFICACI√ìN -->
<div id="tab-ranking" class="tab-content">
<div class="card">
<h3>Clasificaci√≥n</h3>
<div class="toggle-container">
<button id="btnRankTeams" class="small secondary toggle-active" onclick="toggleRankingView('teams')">Equipos</button>
<button id="btnRankPlayers" class="small secondary" onclick="toggleRankingView('players')">Jugadores</button>
</div>
<div id="tieBreakInfo" class="info-box">
<!-- Se llena din√°micamente -->
</div>
<table id="rankingTable">
<thead>
<tr id="rankingHeaderRow">
<th class="rank-col">#</th>
<th>Equipo</th>
<th class="points-col">Pts</th>
<th class="sb-col">Desempate</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
</div>
<!-- TAB 4: EXPORTAR -->
<div id="tab-export" class="tab-content">
<div class="card">
<h3>Exportar a PDF</h3>
<p>Descarga el informe completo con los resultados por equipos y tableros.</p>
<button class="export" onclick="downloadPDF()">‚¨áÔ∏è Descargar PDF</button>
</div>
</div>
</div>
<!-- BOTTOM NAVIGATION -->
<div class="bottom-nav">
<div class="nav-item active" onclick="switchTab('tab-setup', this)">
<span class="nav-icon">‚öôÔ∏è</span>Inicio
</div>
<div class="nav-item" onclick="switchTab('tab-rounds', this)">
<span class="nav-icon">üìÖ</span>Rondas
</div>
<div class="nav-item" onclick="switchTab('tab-ranking', this)">
<span class="nav-icon">üèÜ</span>Ranking
</div>
<div class="nav-item" onclick="switchTab('tab-export', this)">
<span class="nav-icon">üìÑ</span>Exportar
</div>
</div>
<!-- MODAL CONFIRMACI√ìN -->
<div id="confirmModal" class="modal">
<div class="modal-content">
<h3 id="confirmTitle">¬øEst√°s seguro?</h3>
<p id="confirmMessage">Mensaje de confirmaci√≥n.</p>
<div class="modal-buttons">
<button class="secondary" onclick="closeConfirmModal(false)">Cancelar</button>
<button id="confirmActionBtn" onclick="closeConfirmModal(true)">Confirmar</button>
</div>
</div>
</div>
<!-- MODAL CONTRASE√ëA -->
<div id="pwdModal" class="modal">
<div class="modal-content">
<h3>Acceso Admin</h3>
<p>Introduce la contrase√±a:</p>
<input type="password" id="pwdInput" placeholder="Contrase√±a" onkeydown="if(event.key === 'Enter') checkPassword()">
<button onclick="checkPassword()">Entrar</button>
<button class="secondary" onclick="closePasswordModal()" style="margin-top:5px;">Cancelar</button>
</div>
</div>
<!-- TOAST -->
<div id="toast">Notificaci√≥n</div>
<!-- AUDIO -->
<audio id="tapSound" src="https://github.com/ManuelVS8/Efectos_audio/raw/37b3eb2da9c15c04dfb71dfe1be60f088ea3cdfc/Tap.mp3" preload="auto"></audio>
<script>
// --- CONFIG & STATE ---
const ADMIN_PASS = "ajedrez2026";
// URL NUEVA ACTUALIZADA
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxjeWw4PBusWTnT6ekqNgUNyAc8zEY1UjGnnFS-6j-3BRs5BtbdBIIVs8J0Lgl5SACk/exec";
let isAdmin = false;
let appData = { teams: [], matches: [], started: false };
let currentRound =1;
let pendingAction = null;
let rankingViewMode = 'teams';
// --- PWA ---
if ('serviceWorker' in navigator) {
window.addEventListener('load', () => {
navigator.serviceWorker.register('./sw.js')
.then(reg => console.log('SW registrado', reg))
.catch(err => console.log('SW fall√≥', err));
});
}
// --- INIT ---
document.addEventListener('DOMContentLoaded', () => {
fetchFromGoogle();
});
// --- GOOGLE SHEETS INTEGRATION ---
async function fetchFromGoogle() {
showLoading("Cargando datos del torneo...");
try {
const response = await fetch(`${SCRIPT_URL}?action=read&t=${new Date().getTime()}`);
if (!response.ok) throw new Error(`Error HTTP: ${response.status}`);
const text = await response.text();
const data = JSON.parse(text);
if (data && data.db) {
appData = data.db;
} else {
appData = { teams: [], matches: [], started: false };
}
renderUI();
updateAdminMode();
} catch (error) {
console.error("Error cargando datos:", error);
showToast("Error de conexi√≥n");
} finally {
hideLoading();
}
}
// FUNCI√ìN CORREGIDA: NO recargar tras guardar
async function syncToGoogle() {
if (!isAdmin) {
showToast("Modo Solo Lectura");
return;
}
showLoading("Guardando resultados en la nube...");
playTap();
const payload = {
action: 'sync',
teams: JSON.stringify(appData.teams),
matches: JSON.stringify(appData.matches)
};
// Intentamos hasta 2 veces (por si falla la red)
for (let i = 0; i < 2; i++) {
try {
const res = await fetch(SCRIPT_URL, {
method: 'POST',
mode: 'no-cors',
body: JSON.stringify(payload),
headers: { 'Content-Type': 'application/json' }
});
// ‚úÖ NO RECARGAR desde Google tras guardar
showToast("‚úÖ Resultados guardados");
hideLoading();
return;
} catch (e) {
console.warn(`Reintento de guardado (${i+1})...`, e);
if (i === 1) {
showToast("‚ùå Error de red al guardar.");
hideLoading();
}
}
}
}
function sendGoogleAction(action, params = {}) {
return new Promise(async (resolve, reject) => {
showLoading("Procesando...");
try {
let payload = { action: action, ...params };
const response = await fetch(SCRIPT_URL, {
method: 'POST',
mode: 'no-cors',
body: JSON.stringify(payload),
headers: { 'Content-Type': 'application/json' }
});
resolve(true);
} catch (error) {
console.error("Error en acci√≥n Google:", error);
showToast("Error: " + error.message);
reject(error);
} finally {
hideLoading();
}
});
}
function showLoading(text) {
document.getElementById('loadingText').innerText = text;
document.getElementById('loadingOverlay').style.display = "flex";
}
function hideLoading() {
document.getElementById('loadingOverlay').style.display = "none";
}
function playTap() {
const audio = document.getElementById('tapSound');
if(audio) {
audio.currentTime = 0;
audio.play().catch(e => console.log("Audio play blocked"));
}
}
// --- SECURITY / ADMIN ---
function openPasswordModal() {
playTap();
if (isAdmin) {
isAdmin = false;
updateAdminMode();
showToast("Modo Admin desactivado");
} else {
const modal = document.getElementById('pwdModal');
modal.style.display = "flex";
setTimeout(() => document.getElementById('pwdInput').focus(), 100);
}
}
function closePasswordModal() {
playTap();
document.getElementById('pwdModal').style.display = "none";
}
function checkPassword() {
const input = document.getElementById('pwdInput').value;
if (input === ADMIN_PASS) {
playTap();
isAdmin = true;
closePasswordModal();
updateAdminMode();
showToast("Modo Editor activado");
} else {
showToast("Contrase√±a incorrecta");
document.getElementById('pwdInput').value = "";
}
}
function updateAdminMode() {
const btn = document.getElementById('adminBtn');
if (isAdmin) {
btn.innerHTML = "üîì";
btn.classList.add('unlocked');
document.body.classList.remove('is-locked');
} else {
btn.innerHTML = "üîí";
btn.classList.remove('unlocked');
document.body.classList.add('is-locked');
}
}
// --- MODALS ---
function openConfirmModal(title, message, actionType) {
playTap();
document.getElementById('confirmTitle').innerText = title;
document.getElementById('confirmMessage').innerText = message;
const btn = document.getElementById('confirmActionBtn');
btn.className = "";
if (actionType === 'danger') btn.classList.add('danger');
else btn.style.backgroundColor = "var(--primary)";
document.getElementById('confirmModal').style.display = "flex";
pendingAction = actionType;
}
function closeConfirmModal(confirmed) {
playTap();
document.getElementById('confirmModal').style.display = "none";
if (confirmed && pendingAction) {
if (pendingAction === 'start') startTournamentLogic();
else if (pendingAction === 'reset') resetTournamentLogic();
}
pendingAction = null;
}
// --- SETUP LOGIC (TEAMS) ---
function renderTeamsSetup() {
const container = document.getElementById('teamsSetupContainer');
container.innerHTML = "";
appData.teams.forEach((team, index) => {
const teamCard = document.createElement('div');
teamCard.className = 'team-setup-card';
let playersHTML = '';
team.players.forEach((p, pIndex) => {
playersHTML += `
<div class="player-row">
<span class="player-num">${pIndex +1}.</span>
<input type="text" class="editable-element" value="${p.name}" placeholder="Nombre Jugador" onchange="updatePlayerName(${index}, ${pIndex}, this.value)">
${isAdmin ? `<button class="danger small" onclick="removePlayer(${index}, ${pIndex})">√ó</button>` : ''}
</div>
`;
});
teamCard.innerHTML = `
<div class="team-header">
<input type="text" class="editable-element" value="${team.name}" placeholder="Nombre del Equipo" onchange="updateTeamName(${index}, this.value)">
${isAdmin && appData.teams.length >1 ? `<button class="danger small" onclick="removeTeam(${index})">Eliminar</button>` : ''}
</div>
<div class="player-list">${playersHTML}<div style="margin-top: 10px; text-align: center;"><button class="secondary editable-element small" style="width:100%; font-size: 0.8rem;" onclick="addPlayerToTeam(${index})">+ A√±adir Jugador</button></div></div>
`;
container.appendChild(teamCard);
});
}
function addNewTeamUI() {
if(!isAdmin) return;
const newId = Date.now().toString();
appData.teams.push({ id: newId, name: `Equipo ${appData.teams.length +1}`, players: [ { id: newId + "_p1", name: "" }, { id: newId + "_p2", name: "" } ] });
renderTeamsSetup(); playTap();
}
function removeTeam(teamIndex) {
if(!isAdmin) return;
openConfirmModal("Eliminar Equipo", "¬øSeguro que quieres eliminar este equipo?", 'custom');
pendingAction = () => {
  appData.teams.splice(teamIndex, 1);
  renderTeamsSetup();
  playTap();
};
}
function updateTeamName(index, val) { appData.teams[index].name = val; }
function addPlayerToTeam(teamIndex) {
if(!isAdmin) return;
const teamId = appData.teams[teamIndex].id;
appData.teams[teamIndex].players.push({ id: teamId + "_p" + (Date.now()), name: "" });
renderTeamsSetup();
}
function removePlayer(teamIndex, playerIndex) {
if(!isAdmin) return;
openConfirmModal("Eliminar Jugador", "¬øSeguro que quieres eliminar este jugador?", 'custom');
pendingAction = () => {
  appData.teams[teamIndex].players.splice(playerIndex, 1);
  renderTeamsSetup();
  playTap();
};
}
function updatePlayerName(teamIndex, playerIndex, val) {
appData.teams[teamIndex].players[playerIndex].name = val;
}
// --- TOURNAMENT LOGIC ---
function confirmStartTournament() {
if (!isAdmin) return showToast("Necesitas ser Admin");
const validTeams = appData.teams.filter(t => t.players.length > 0);
if (validTeams.length < 2) return showToast("Se necesitan al menos 2 equipos con jugadores");
let title = "Crear Torneo";
let msg = "¬øSeguro que quieres crear el torneo con estos equipos?";
if (appData.started) {
title = "Actualizar Torneo";
msg = "ATENCI√ìN: Esto borrar√° los resultados actuales y generar√° nuevos emparejamientos.";
}
openConfirmModal(title, msg, 'start');
}
function startTournamentLogic() {
playTap();
appData.teams.forEach(t => {
t.name = t.name.trim() || "Sin Nombre";
t.players.forEach(p => p.name = p.name.trim());
});
let teams = [...appData.teams];
if (teams.length % 2 !== 0) teams.push({ id: "bye", name: "BYE", players: [] });
const totalRounds = teams.length - 1;
const matches = [];
let matchIdCounter = 0;
for (let round = 0; round < totalRounds; round++) {
for (let i = 0; i < teams.length / 2; i++) {
const teamA = teams[i];
const teamB = teams[teams.length - 1 - i];
if (teamA.id !== "bye" && teamB.id !== "bye") {
const teamMatchId = `r${round+1}_tm${matchIdCounter}`;
const numBoards = Math.min(teamA.players.length, teamB.players.length);
if (numBoards > 0) {
// Determinar qui√©n lleva blancas en tableros impares: alternar por ronda
// Regla FIDE: si round es impar ‚Üí teamA tiene blancas en tableros impares
//            si round es par   ‚Üí teamB tiene blancas en tableros impares
const team1IsWhiteOnOdd = (round % 2 === 0); // round empieza en 0 ‚Üí ronda 1 = round=0 ‚Üí true

for (let b = 0; b < numBoards; b++) {
matches.push({
id: `${teamMatchId}_b${b+1}`, round: round + 1, teamMatchId: teamMatchId,
team1Id: teamA.id, team2Id: teamB.id,
player1Id: teamA.players[b].id, player2Id: teamB.players[b].id,
boardNum: b + 1, result: "",
team1IsWhiteOnOddBoards: team1IsWhiteOnOdd
});
}
}
matchIdCounter++;
}
}
teams = [teams[0], teams[teams.length - 1], ...teams.slice(1, teams.length - 1)];
}
appData.matches = matches;
appData.started = true;
sendGoogleAction('create', { teams: appData.teams }).then(success => {
appData.matches = matches; renderUI();
switchTab('tab-rounds', document.querySelectorAll('.nav-item')[1]);
showToast("Torneo creado");
}).catch(err => {
console.error(err); renderUI(); showToast("Torneo creado (Modo Local)");
});
}
function confirmResetTournament() {
if (!isAdmin) return;
openConfirmModal("Borrar Todo", "ATENCI√ìN: Se eliminar√° toda la informaci√≥n.", 'reset');
}
function resetTournamentLogic() {
playTap();
sendGoogleAction('reset').then(success => {
appData = { teams: [], matches: [], started: false };
renderUI(); showToast("Torneo borrado");
}).catch(err => {
appData = { teams: [], matches: [], started: false };
renderUI(); showToast("Torneo borrado (Modo Local)");
});
}
function updateMatch(matchId, result) {
if (!isAdmin) return;
playTap();
const match = appData.matches.find(m => m.id === matchId);
if (match) match.result = result;
renderMatches(currentRound); renderRoundSelector();
}
// --- RENDERING ---
function renderUI() {
if (appData.started) {
document.getElementById('resetCard').style.display = "block";
renderRoundSelector();
renderMatches(currentRound);
renderRanking();
} else {
document.getElementById('resetCard').style.display = "none";
document.getElementById('roundSelector').innerHTML = "";
document.getElementById('matchesContainer').innerHTML = "<p style='text-align:center'>No hay torneo activo.</p>";
document.querySelector('#rankingTable tbody').innerHTML = "";
}
renderTeamsSetup();
}
function renderRoundSelector() {
const totalRounds = appData.matches.length > 0 ? Math.max(...appData.matches.map(m => m.round)) : 0;
const container = document.getElementById('roundSelector');
container.innerHTML = "";
for (let i = 1; i <= totalRounds; i++) {
const chip = document.createElement('div');
let classes = ["round-chip"];
const roundMatches = appData.matches.filter(m => m.round === i);
const hasResults = roundMatches.some(m => m.result !== "");
if (hasResults) classes.push("has-results");
if (i === currentRound) classes.push("active");
chip.className = classes.join(" ");
chip.innerText = `Ronda ${i}`;
chip.onclick = () => { playTap(); currentRound = i; renderRoundSelector(); renderMatches(i); };
container.appendChild(chip);
}
}
// FUNCI√ìN OPTIMIZADA PARA EL SELECT
function renderMatches(roundNum) {
const container = document.getElementById('matchesContainer');
container.innerHTML = "";
const roundMatches = appData.matches.filter(m => m.round === roundNum);
if (roundMatches.length === 0) {
container.innerHTML = "<p>No hay partidas para esta ronda.</p>";
return;
}
// Agrupar por teamMatchId
const teamGroups = {};
roundMatches.forEach(m => { if (!teamGroups[m.teamMatchId]) teamGroups[m.teamMatchId] = []; teamGroups[m.teamMatchId].push(m); });
Object.keys(teamGroups).forEach(gId => {
const groupMatches = teamGroups[gId];
const t1 = appData.teams.find(t => t.id === groupMatches[0].team1Id);
const t2 = appData.teams.find(t => t.id === groupMatches[0].team2Id);
let score1 = 0, score2 = 0;
groupMatches.forEach(m => {
if (m.result === '1-0') score1++;
else if (m.result === '0-1') score2++;
else if (m.result === '1/2-1/2') { score1 += 0.5; score2 += 0.5; }
});
const card = document.createElement('div');
card.className = 'team-match-card';
card.innerHTML = `
<div class="team-match-header">
<div style="text-align:center; flex:1;"><div class="team-names">${t1.name}</div><div class="team-subtitle">Local</div></div>
<div class="team-score-display" style="color:${score1 > score2 ? 'var(--win-color)' : (score2 > score1 ? 'var(--loss-color)' : 'var(--text)')}">${score1} - ${score2}</div>
<div style="text-align:center; flex:1;"><div class="team-names">${t2.name}</div><div class="team-subtitle">Visitante</div></div>
</div>
`;
// Generar tableros
groupMatches.forEach(m => {
const p1 = t1.players.find(p => p.id === m.player1Id);
const p2 = t2.players.find(p => p.id === m.player2Id);
let p1Class = "board-p1", p2Class = "board-p2";
const isBoardOdd = (m.boardNum % 2 !== 0);
const team1HasWhite = m.team1IsWhiteOnOddBoards ? isBoardOdd : !isBoardOdd;
const icon1 = team1HasWhite ? "‚ôî" : "‚ôö";
const icon2 = team1HasWhite ? "‚ôö" : "‚ôî";
if (m.result === '1-0') {
  if (team1HasWhite) { p1Class += " win"; p2Class += " loss"; }
  else { p2Class += " win"; p1Class += " loss"; }
} else if (m.result === '0-1') {
  if (team1HasWhite) { p2Class += " win"; p1Class += " loss"; }
  else { p1Class += " win"; p2Class += " loss"; }
}
else if (m.result === '1/2-1/2') { p1Class += " draw"; p2Class += " draw"; }
const boardDiv = document.createElement('div');
boardDiv.className = 'board-row';
const selectDiv = document.createElement('div');
selectDiv.style.marginTop = "5px";
selectDiv.innerHTML = `
<div class="board-players">
<div class="${p1Class}">${icon1} ${p1 ? p1.name : 'N/A'}</div>
<div style="font-size:0.8rem; color:#999; margin:0 5px;">vs</div>
<div class="${p2Class}">${p2 ? p2.name : 'N/A'} ${icon2}</div>
</div>
`;
const selectElement = document.createElement('select');
selectElement.className = 'board-select editable-element';
// A√±adir opciones
const opts = [
{val: "", txt: "Seleccionar resultado..."},
{val: "1-0", txt: "1-0 (Ganan Blancas)"},
{val: "0-1", txt: "0-1 (Ganan Negras)"},
{val: "1/2-1/2", txt: "¬Ω-¬Ω (Tablas)"}
];
opts.forEach(opt => {
const option = document.createElement('option');
option.value = opt.val;
option.text = opt.txt;
if (m.result === opt.val) option.selected = true;
selectElement.appendChild(option);
});
// A√±adir listener de evento de forma segura
selectElement.addEventListener('change', (e) => {
updateMatch(m.id, e.target.value);
});
// üîß CORRECCI√ìN CR√çTICA: forzar valor expl√≠cito del select
selectElement.value = m.result;

selectDiv.appendChild(selectElement);
boardDiv.appendChild(selectDiv);
card.appendChild(boardDiv);
});
container.appendChild(card);
});
}
function toggleRankingView(mode) {
playTap();
rankingViewMode = mode;
document.getElementById('btnRankTeams').className = mode === 'teams' ? 'small secondary toggle-active' : 'small secondary';
document.getElementById('btnRankPlayers').className = mode === 'players' ? 'small secondary toggle-active' : 'small secondary';
renderRanking();
}
// --- RANKING LOGIC (COMPLEX) ---
function renderRanking() {
const thead = document.querySelector('#rankingTable thead');
const tbody = document.querySelector('#rankingTable tbody');
const infoBox = document.getElementById('tieBreakInfo');
tbody.innerHTML = "";
thead.innerHTML = "";
const headerRow = document.createElement('tr');
if (rankingViewMode === 'teams') {
// INFO BOX ACTUALIZADO (Sin nombre)
infoBox.innerHTML = `<strong>Sistema de Desempate (Equipos):</strong>
1. Puntos de Partida &gt; 2. Encuentro Directo (EDE) &gt;
3. Sonnenborn-Berger &gt; 4. Partidas Ganadas &gt; 5. Tableros Sup. &gt; 6. Koya`;
headerRow.innerHTML = `
<th class="rank-col">#</th>
<th>Equipo</th>
<th class="points-col">Pts</th>
<th class="sb-col">Wins</th>
`;
thead.appendChild(headerRow);
// L√≥gica Equipos (Casi id√©ntica a la versi√≥n anterior)
const stats = calculateTeamStats(appData.teams, appData.matches);
stats.sort((a, b) => compareTeams(a, b, stats));
stats.forEach((t, index) => {
const tr = document.createElement('tr');
tr.innerHTML = `
<td class="rank-col">${index + 1}</td>
<td>${t.name}</td>
<td class="points-col">${t.points}</td>
<td class="sb-col">${t.wins}</td>
`;
tbody.appendChild(tr);
});
} else {
// --- NUEVA L√ìGICA INDIVIDUAL ---
// INFO BOX ACTUALIZADO (Sin nombre)
infoBox.innerHTML = `<strong>Sistema de Desempate (Jugadores):</strong>
1. Puntos Totales &gt; 2. Sonnenborn-Berger &gt; 3. Encuentro Directo (EDE) &gt;
4. Mayor n¬∫ de Victorias &gt; 5. Mayor n¬∫ de Negras`;
headerRow.innerHTML = `
<th class="rank-col">#</th>
<th>Jugador (Equipo)</th>
<th class="points-col">Pts</th>
<th class="sb-col">SB</th>
`;
thead.appendChild(headerRow);
// 1. Preparar lista plana de jugadores
let playersList = [];
appData.teams.forEach(t => {
t.players.forEach(p => {
playersList.push({
id: p.id,
name: p.name,
teamName: t.name,
points: 0,
wins: 0,
blackGames: 0,
opponents: [] // Guardaremos ID de oponentes
});
});
});
// 2. Calcular Puntos, Wins, Negras y mapear oponentes
appData.matches.forEach(m => {
let p1 = playersList.find(x => x.id === m.player1Id);
let p2 = playersList.find(x => x.id === m.player2Id);
if (p1 && p2) {
// Negras:
// Si tablero es impar (1,3...): P1 es Blanco, P2 es Negro.
// Si tablero es par (2,4...): P1 es Negro, P2 es Blanco.
const isP1Black = (m.boardNum % 2 === 0);
if (isP1Black) p1.blackGames++;
else p2.blackGames++;
p1.opponents.push(p2.id);
p2.opponents.push(p1.id);
if (m.result === '1-0') { p1.points++; p1.wins++; }
else if (m.result === '0-1') { p2.points++; p2.wins++; }
else if (m.result === '1/2-1/2') { p1.points += 0.5; p2.points += 0.5; }
}
});
// 3. Calcular Sonnenborn-Berger
// Necesitamos los puntos finales de TODOS para calcularlo correctamente
playersList.forEach(p => {
let sb = 0;
p.opponents.forEach(oppId => {
let opp = playersList.find(x => x.id === oppId);
if (opp) {
// Encontrar resultado contra este oponente
const match = appData.matches.find(m =>
(m.player1Id === p.id && m.player2Id === oppId) ||
(m.player1Id === opp.id && m.player2Id === p.id)
);
if (match && match.result) {
let myScore = 0;
if (match.player1Id === p.id) {
if (match.result === '1-0') myScore = 1;
else if (match.result === '0-1') myScore = 0;
else myScore = 0.5;
} else {
if (match.result === '1-0') myScore = 0;
else if (match.result === '0-1') myScore = 1;
else myScore = 0.5;
}
// SB Formula: Sumar puntos oponentes * (1 si gano, 0.5 si empato)
if (myScore === 1) sb += opp.points;
else if (myScore === 0.5) sb += (opp.points * 0.5);
}
}
});
p.sb = sb;
});
// 4. Ordenamiento (Comparador Completo)
playersList.sort((a, b) => compareIndividuals(a, b, playersList));
// 5. Renderizar
playersList.forEach((p, index) => {
const tr = document.createElement('tr');
tr.innerHTML = `
<td class="rank-col">${index + 1}</td>
<td>
<div style="font-weight:bold;">${p.name}</div>
<div style="font-size:0.8rem; color:#777;">${p.teamName}</div>
</td>
<td class="points-col">${p.points}</td>
<td class="sb-col">${p.sb.toFixed(1)}</td>
`;
tbody.appendChild(tr);
});
}
}
// Comparador Individual Estricto
function compareIndividuals(a, b, allPlayers) {
// 1. Puntos
if (Math.abs(b.points - a.points) > 0.001) return b.points - a.points;
// 2. Sonnenborn-Berger
if (Math.abs(b.sb - a.sb) > 0.001) return b.sb - a.sb;
// 3. Encuentro Directo (EDE)
const tiedGroup = allPlayers.filter(p => Math.abs(p.points - a.points) < 0.001 && Math.abs(p.sb - a.sb) < 0.001);
if (tiedGroup.length === 2) {
const opp = tiedGroup.find(t => t.id !== a.id);
// Buscar partido
const match = appData.matches.find(m =>
(m.player1Id === a.id && m.player2Id === opp.id) ||
(m.player1Id === opp.id && m.player2Id === a.id)
);
if (match && match.result) {
let scoreA = 0, scoreB = 0;
if (match.player1Id === a.id) {
if (match.result === '1-0') scoreA = 1;
else if (match.result === '0-1') scoreB = 1;
else { scoreA = 0.5; scoreB = 0.5; }
} else {
if (match.result === '1-0') scoreB = 1;
else if (match.result === '0-1') scoreA = 1;
else { scoreA = 0.5; scoreB = 0.5; }
}
if (scoreA !== scoreB) return scoreB - scoreA;
}
} else if (tiedGroup.length > 2) {
// Mini-liga (Subgrupo)
const mutualA = getMutualPointsPlayer(a.id, tiedGroup);
const mutualB = getMutualPointsPlayer(b.id, tiedGroup);
if (Math.abs(mutualB - mutualA) > 0.001) return mutualB - mutualA;
}
// 4. Mayor n√∫mero de victorias
if (b.wins !== a.wins) return b.wins - a.wins;
// 5. Mayor n√∫mero de partidas con negras
if (b.blackGames !== a.blackGames) return b.blackGames - a.blackGames;
// 6. Nombre (Oculto en la UI, pero usado internamente)
return a.name.localeCompare(b.name);
}
function getMutualPointsPlayer(playerId, group) {
let score = 0;
const groupIds = group.map(p => p.id);
// Buscar partidas de este jugador contra cualquiera del grupo
const myMatches = appData.matches.filter(m => m.player1Id === playerId || m.player2Id === playerId);
myMatches.forEach(m => {
const oppId = m.player1Id === playerId ? m.player2Id : m.player1Id;
if (groupIds.includes(oppId)) {
if (m.player1Id === playerId) {
if (m.result === '1-0') score++;
else if (m.result === '0-1') score += 0;
else score += 0.5;
} else {
if (m.result === '1-0') score += 0;
else if (m.result === '0-1') score++;
else score += 0.5;
}
}
});
return score;
}
// --- FUNCIONES EQUIPOS (Mantenidas de la versi√≥n anterior) ---
function calculateTeamStats(teams, matches) {
const teamPoints = {};
teams.forEach(t => teamPoints[t.id] = 0);
matches.forEach(m => {
if (m.result === '1-0') { if(teamPoints[m.team1Id] !== undefined) teamPoints[m.team1Id]++; }
else if (m.result === '0-1') { if(teamPoints[m.team2Id] !== undefined) teamPoints[m.team2Id]++; }
else if (m.result === '1/2-1/2') { if(teamPoints[m.team1Id] !== undefined) teamPoints[m.team1Id] += 0.5; if(teamPoints[m.team2Id] !== undefined) teamPoints[m.team2Id] += 0.5; }
});
return teams.map(t => {
let wins = 0;
let boardPoints = [];
let points = teamPoints[t.id] || 0;
matches.forEach(m => {
if (m.team1Id === t.id || m.team2Id === t.id) {
const isT1 = m.team1Id === t.id;
let boardIdx = m.boardNum - 1;
if(!boardPoints[boardIdx]) boardPoints[boardIdx] = 0;
let pts = 0;
if (m.result === '1-0') pts = isT1 ? 1 : 0;
else if (m.result === '0-1') pts = isT1 ? 0 : 1;
else if (m.result === '1/2-1/2') pts = 0.5;
if (pts === 1) wins++;
boardPoints[boardIdx] += pts;
}
});
let sb = 0, koya = 0, oppScores = [];
teams.forEach(opp => {
if (opp.id === t.id) return;
const match = matches.find(m => (m.team1Id === t.id && m.team2Id === opp.id) || (m.team1Id === opp.id && m.team2Id === t.id));
if (match && match.result) {
const oppTotalPts = teamPoints[opp.id] || 0;
oppScores.push(oppTotalPts);
let myScore = 0;
if (match.team1Id === t.id) { if(match.result === '1-0') myScore = 1; else if(match.result === '0-1') myScore = 0; else myScore = 0.5; }
else { if(match.result === '1-0') myScore = 0; else if(match.result === '0-1') myScore = 1; else myScore = 0.5; }
sb += (myScore * oppTotalPts);
}
});
if (oppScores.length > 0) {
oppScores.sort((a,b) => a - b); oppScores.shift();
koya = oppScores.reduce((sum, val) => sum + val, 0);
}
return { id: t.id, name: t.name, points: points, wins: wins, boardPoints: boardPoints, sb: sb, koya: koya, oppScores: oppScores };
});
}
function compareTeams(a, b, allStats) {
  // 1. Match Points
  if (Math.abs(b.points - a.points) > 0.001) return b.points - a.points;

  const tiedGroup = allStats.filter(s => Math.abs(s.points - a.points) < 0.001);

  // 2. Encuentro directo (solo si son 2)
  if (tiedGroup.length === 2) {
    const opp = tiedGroup.find(t => t.id !== a.id);
    const match = appData.matches.find(m =>
      (m.team1Id === a.id && m.team2Id === opp.id) ||
      (m.team1Id === opp.id && m.team2Id === a.id)
    );
    if (match && match.result) {
      let scoreA = 0;
      if (match.team1Id === a.id) {
        if (match.result === '1-0') scoreA = 1;
        else if (match.result === '0-1') scoreA = 0;
        else scoreA = 0.5;
      } else {
        if (match.result === '1-0') scoreA = 0;
        else if (match.result === '0-1') scoreA = 1;
        else scoreA = 0.5;
      }
      const scoreB = 1 - scoreA;
      if (scoreA !== scoreB) return scoreB - scoreA;
    }
  }

  // 3. Sonneborn-Berger
  if (Math.abs(b.sb - a.sb) > 0.001) return b.sb - a.sb;

  // 4. Game Points (suma total de puntos en tableros)
  const totalGamePoints = (team) => {
    let sum = 0;
    appData.matches.forEach(m => {
      if (m.team1Id === team.id || m.team2Id === team.id) {
        const isT1 = m.team1Id === team.id;
        if (m.result === '1-0') sum += isT1 ? 1 : 0;
        else if (m.result === '0-1') sum += isT1 ? 0 : 1;
        else if (m.result === '1/2-1/2') sum += 0.5;
      }
    });
    return sum;
  };
  const gpA = totalGamePoints(a);
  const gpB = totalGamePoints(b);
  if (Math.abs(gpB - gpA) > 0.001) return gpB - gpA;

  // 5. Partidas ganadas (ya tienes wins)
  if (b.wins !== a.wins) return b.wins - a.wins;

  // 6. Koya System
  if (Math.abs(b.koya - a.koya) > 0.001) return b.koya - a.koya;

  // 7. Nombre (√∫ltimo recurso)
  return a.name.localeCompare(b.name);
}
function getMutualPoints(teamId, group) {
let score = 0;
const teamOpponents = group.filter(t => t.id !== teamId).map(t => t.id);
teamOpponents.forEach(oppId => {
const match = appData.matches.find(m => (m.team1Id === teamId && m.team2Id === oppId) || (m.team1Id === oppId && m.team2Id === teamId));
if (match && match.result) {
if (match.team1Id === teamId) { if (match.result === '1-0') score++; else if (match.result === '0-1') score += 0; else score += 0.5; }
else { if (match.result === '1-0') score += 0; else if (match.result === '0-1') score++; else score += 0.5; }
}
});
return score;
}
function switchTab(tabId, navItem) {
playTap();
document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
document.getElementById(tabId).classList.add('active');
document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
navItem.classList.add('active');
if (tabId === 'tab-ranking') renderRanking();
}
function showToast(message) {
const x = document.getElementById("toast");
x.innerText = message;
x.className = "show";
setTimeout(function(){ x.className = x.className.replace("show", ""); }, 3000);
}
// --- PDF LOGIC ---
function downloadPDF() {
playTap();
if (!appData.started) return showToast("No hay datos para exportar");
const { jsPDF } = window.jspdf;
const doc = new jsPDF();
const pageWidth = doc.internal.pageSize.getWidth();
const margin = 15;
let y = 20;
doc.setFontSize(18);
doc.setTextColor(44, 62, 80);
doc.text("Ajedrez Siurot - Torneo por Equipos", margin, y);
y += 10;
doc.setFontSize(12);
doc.setTextColor(100);
doc.text(`Fecha: ${new Date().toLocaleDateString('es-ES')}`, margin, y);
y += 15;
// 1. CLASIFICACI√ìN EQUIPOS
doc.setFontSize(14);
doc.setTextColor(0);
doc.text("Clasificaci√≥n de Equipos", margin, y);
y += 10;
const col1 = margin;
const col2 = margin + 10;
const col3 = margin + 60;
const col4 = pageWidth - margin;
doc.setFontSize(10);
doc.setFont("helvetica", "bold");
doc.text("#", col1, y);
doc.text("Equipo", col2, y);
doc.text("Puntos", col4, y, { align: "right" });
y += 7;
doc.setFont("helvetica", "normal");
const stats = calculateTeamStats(appData.teams, appData.matches);
stats.sort((a, b) => compareTeams(a, b, stats));
stats.forEach((t, i) => {
if (y > 270) { doc.addPage(); y = 20; }
doc.text(`${i + 1}`, col1, y);
doc.text(t.name, col2, y);
doc.text(`${t.points}`, col4, y, { align: "right" });
y += 7;
});
// 2. RESULTADOS POR RONDA (CON T√çTULOS)
doc.addPage();
y = 20;
doc.setFontSize(16);
doc.setTextColor(44, 62, 80);
doc.text("Detalle de Partidas", margin, y);
y += 15;
const totalRounds = appData.matches.length > 0 ? Math.max(...appData.matches.map(m => m.round)) : 0;
for (let r = 1; r <= totalRounds; r++) {
const rMatches = appData.matches.filter(m => m.round === r);
if (rMatches.length === 0) continue;
// Chequeo de salto de p√°gina antes de la ronda
if (y > 230) {
doc.addPage();
y = 20;
}
// T√≠tulo de Ronda
doc.setFontSize(13);
doc.setFont("helvetica", "bold");
doc.setTextColor(0);
doc.text(`Ronda ${r}`, margin, y);
y += 8;
// L√≠nea separadora sutil (opcional pero est√©tico)
doc.setDrawColor(200);
doc.setLineWidth(0.5);
doc.line(margin, y, pageWidth - margin, y);
y += 8;
// Grupos de enfrentamientos de esta ronda
const groups = {};
rMatches.forEach(m => {
if(!groups[m.teamMatchId]) groups[m.teamMatchId] = [];
groups[m.teamMatchId].push(m);
});
Object.values(groups).forEach(g => {
// Chequeo dentro de la ronda
if (y > 270) { doc.addPage(); y = 20; }
const t1 = appData.teams.find(t => t.id === g[0].team1Id);
const t2 = appData.teams.find(t => t.id === g[0].team2Id);
doc.setFont("helvetica", "bold");
doc.setFontSize(11);
doc.setTextColor(44, 62, 80);
const matchTitle = `${t1.name} vs ${t2.name}`;
doc.text(matchTitle, margin, y);
y += 6;
doc.setFontSize(9);
doc.setFont("helvetica", "normal");
doc.setTextColor(0);
g.forEach(m => {
if (y > 270) { doc.addPage(); y = 20; }
const p1 = t1.players.find(p => p.id === m.player1Id);
const p2 = t2.players.find(p => p.id === m.player2Id);
const res = m.result ? m.result : "Pendiente";
doc.text(` Tablero ${m.boardNum}: ${p1?p1.name:'?'} vs ${p2?p2.name:'?'} [${res}]`, margin, y);
y += 5;
});
y += 4; // Espacio tras el enfrentamiento
});
y += 6; // Espacio extra tras la ronda
}
doc.save("Resultado_Torneo_Equipos_Siurot.pdf");
showToast("PDF generado");
}
// --- MANEJO DE VISIBILIDAD (Correcci√≥n para despertar m√≥vil) ---
document.addEventListener("visibilitychange", () => {
if (document.visibilityState === "visible") {
console.log("Aplicaci√≥n visible (Desbloqueo)");
// Asegurar que no haya un bloqueo de carga fantasma
hideLoading();
// Si el modal de contrase√±a est√° abierto, forzar el foco
const pwdModal = document.getElementById('pwdModal');
if (pwdModal && pwdModal.style.display === "flex") {
// Timeout peque√±o para dar tiempo al navegador de "despertar" el DOM
setTimeout(() => {
const input = document.getElementById('pwdInput');
if(input) input.focus();
}, 300);
}
}
});
</script>
</body>
</html>